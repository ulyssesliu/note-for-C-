# C++（4）
- 与类有关的几类**关键词**
- 每一类都分别包含 **数据** 和 **函数**
> - 静态 static
> - 友元 friend
> - 常量 const

## 一、静态成员
###  1. 静态数据
1. 本质：仅在寄存器中**保存一次**，生命期为**整个程序周期**
2. 功能：在程序运行之前就已存在于内存中，只依赖**类**而不依赖具体的**对象**，可直接通过类调用
3. 语法：初始化必须在**类外**（因为此数据本质上不属于具体对象，故不能随构造函数初始化）
```c++
class Myclass{
  static int id;  
};

Myclass::id = 10; //必须在类外初始化
int n = Myclass::id; //注意此时没有类型为Myclass的对象，但依然能调用id的值，因为其在程序开始运行之前就已存在于内存中
```

### 2. 类内的静态函数
1. 本质：独立于实际对象而存在的类函数
2. 功能：能通过类名直接调用，而无需考虑是否创建对象
3. 语法：
> 1. 定义：类内类外都可以（与静态数据不同）
> 2. 访问：直借通过类名
> 3. 可调用的参数：局部变量，形参（废话）以及**该类中的静态数据**。
```c++
class MyClass{
  	static int id;
public:
	void fun(){}; // 类内定义
    void fun1(); 
};
void MyClass::fun1(){} //类内声明，类外定义
```

### 3. 补充：类外的静态函数
- 与C相同，表示作用域为当前的文件（即不可跨文件调用，与不加以及extern关键词相反）    


  
    

## 二、友元成员

### 1. 友元函数
1. 本质：让**非类内函数**无视封装**调用类内数据**，使得封装的特性更灵活
2. 功能：让类外函数可调用类内的所有访问级别的数据
3. 语法：
> 类内声明（确定是谁的friend），类外定义（本质上不是类内函数）
> 参数通常包含对类的引用（不然为啥要定义成friend呢）
```c++
class MyClass{
    int id = 10;
	friend void fun(MyClass &c);
};

void fun(MyClass &c)
{
    cout << c.id << endl;
}//效果：在命令行输出10
```
### 2. 友元类
1. 本质：允许另一个类单向访问一个类的所有成员
2. 语法：
> 类内声明，类外定义
```c++
class MyClass{
    int id = 10;
	friend class B;
};

class B{
    void fun(MyClass &a)
    {
        cout << a.id << endl;
    }
};
```

### 3. 总结：三个特性
> 单方向：B是A的友元，则 B能调用A的成员，但A不能调用B的任何成员
> 不传递：A是B的友元，B是C的友元，但A和C无关
> 不继承：A是B的友元，B是C的父亲，但A与C无关





## 三、常量成员
### 1. 常量数据
1. 本质：将数据设为只读（具体实现是让编译器对一切修改行为报错）
2. 初始化方法：**初始化列表**
```c++
class MyClass{
    const int id;
    int score;
public:
    MyClass():id(10),score(20) //在():后的即为初始化列表，对非静态数据通用；但若const不以此初始化，可能会报错
    {}
};
```
### 2. 常量函数
1. 本质：对this指向的数据域只读的函数（注意，static不被this所指，故可被常量函数修改）
2. 功能：提高程序员的容错率，从而提升代码安全性
3. 语法：注意const是标记在”函数名()“与“{}“之间的
```c++
class MyClass{
    static int id;
    int score
public：
    void fun()const
	{
    	score = 10; //类内实现；修改了this内的数据，编译时会报错
	}
    void fun1()const; //类内声明，类外实现
};

void MyClass::fun1()const{
    id = 10; //id变量是静态数据，不被this指针所指，所以可以被常量函数修改，故此函数执行编译时报错
}
```
### 3. 常量对象
1. 本质：实例化一个只读的数据对象
2. 功能：除静态数据外的所有数据不可读，同时只能调用常量函数，从而**保护**该对象内的数据
